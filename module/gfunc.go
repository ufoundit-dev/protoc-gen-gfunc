package module

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
	"github.com/ufoundit-dev/protoc-gen-gfunc/gfunc"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Func struct {
	MessageName string
	FuncName    string
	Values      map[string]string
}

func GG() {
	opts := &protogen.Options{}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			_, err := generateFile(gen, f)
			if nil != err {
				return err
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + "_gfunc.pb.go"
	fmt.Fprintln(os.Stderr, "====fullname: ", file.Desc.Path())
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-gfunc. DO NOT EDIT.")
	g.P("// source: ", *file.Proto.Name)

	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, msg := range file.Messages {

		opts := msg.Desc.Options().(*descriptorpb.MessageOptions)
		if nil == opts {
			continue
		}

		vv := proto.GetExtension(opts, gfunc.E_Gfunc)
		if vv == nil {
			continue
		}

		fmt.Fprintf(os.Stderr, "====:msg, %v\n", *msg)
		fmt.Fprintf(os.Stderr, "====:opts, %v\n", opts)
		fmt.Fprintf(os.Stderr, "====:vv, %v\n", vv)

		gfuncOptions := vv.(*gfunc.GfuncMessageOptions)
		for _, f := range gfuncOptions.Funcs {
			funcObj := Func{MessageName: msg.GoIdent.GoName, FuncName: f.Name, Values: f.Values}
			tmpl, err := template.ParseFiles(f.Template)
			if nil != err {
				return nil, err
			}

			fmt.Fprintf(os.Stderr, "====:funcObj, %v\n", funcObj)
			by := bytes.NewBuffer(nil)
			tmpl.Execute(by, funcObj)

			g.P("// template: ", f.Template)
			g.P(by.String())
		}
	}

	return g, nil
	// g.P(*templateFile)

	// by := bytes.NewBuffer(nil)

	// g.P(by.String())

	return g, nil
}

type gfunc_module struct {
	*pgs.ModuleBase
	pgsgo.Context
}

func New() pgs.Module {
	fmt.Fprintln(os.Stderr, "---- New")
	return &gfunc_module{ModuleBase: &pgs.ModuleBase{}}
}

func (m *gfunc_module) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.Context = pgsgo.InitContext(c.Parameters())
}

func (gfunc_module) Name() string {
	return "gfunc"
}

func (m gfunc_module) Execute(targets map[string]pgs.File, packages map[string]pgs.Package) []pgs.Artifact {
	fmt.Fprintln(os.Stderr, "---- Execute")
	fmt.Fprintln(os.Stderr, "---- Parameters", m.Parameters())
	fmt.Fprintln(os.Stderr, targets)

	for _, f := range targets {
		gfname := m.Context.OutputPath(f).SetExt(".go").String()
		fmt.Fprintln(os.Stderr, "---- gfname", gfname)
	}
	return m.Artifacts()
}

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
}
