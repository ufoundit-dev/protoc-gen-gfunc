package main

import (
	"bytes"
	"text/template"

	"github.com/ufoundit-dev/protoc-gen-gfunc/gfunc"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type Func struct {
	MessageName string
	FuncName    string
	Values      map[string]string
}

func main() {
	opts := &protogen.Options{}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			_, err := generateFile(gen, f)
			if nil != err {
				return err
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + "_gfunc.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-gfunc. DO NOT EDIT.")
	g.P("// source: ", *file.Proto.Name)

	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	isempty := true

	for _, msg := range file.Messages {

		opts := msg.Desc.Options().(*descriptorpb.MessageOptions)
		if nil == opts {
			continue
		}

		vv := proto.GetExtension(opts, gfunc.E_Gfunc)
		if vv == nil {
			continue
		}

		// fmt.Fprintf(os.Stderr, "====:msg, %v\n", *msg)
		// fmt.Fprintf(os.Stderr, "====:opts, %v\n", opts)
		// fmt.Fprintf(os.Stderr, "====:vv, %v\n", vv)

		gfuncOptions := vv.(*gfunc.GfuncMessageOptions)
		for _, f := range gfuncOptions.Funcs {
			funcObj := Func{MessageName: msg.GoIdent.GoName, FuncName: f.Name, Values: f.Values}
			tmpl, err := template.ParseFiles(f.Template)
			if nil != err {
				return nil, err
			}

			by := bytes.NewBuffer(nil)
			tmpl.Execute(by, funcObj)

			isempty = false

			g.P("// template: ", f.Template)
			g.P(by.String())
		}
	}

	if isempty {
		g.Skip()
	}

	return g, nil
}
